#include <REG51F380.H>
	
// WORKSHOP

; STATE IDLE -> 10s de espera
; STATE TANK_LEVEL -> lê P4 e 
;						 < 40 -> TANK_FILL
;						 > 40 e < 50 -> IDLE	
; 						 > 50 -> ALERT
; STATE_FILL -> encher até P0.1
; STATE_ALERT -> P2.7 piscar de 500ms até P0.7



CSEG AT 0H
	LJMP MAIN
	
CSEG AT 0003H
	LJMP ISR_EXT0
	
CSEG AT 0BH														
	LJMP ISR_TIMER0
	
ISR_EXT0:
	SETB TIMEOUT_ALERT
	RETI
	
ISR_TIMER0:
	PUSH PSW
	PUSH ACC
	PUSH DPL
	PUSH DPH
	MOV TH0, #HIGH(-40000)
	MOV TL0, #LOW(-40000)
	
	MOV DPTR, #T_TABLE
	MOV A, STATE
	RL A
	JMP @A + DPTR
	
	T_IDLE:
		MOV A, VTIME_L
		ADD A, #1
		MOV VTIME_L, A
		LCALL RECARGA		; necessário para recarregar valor de VTIME_L, se houve carry
		MOV A, VTIME_H
		ADDC A, #0
		MOV VTIME_H, A
		MOV TIMEOUT, C
		CLR TF2H
		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI
		
	T_ALERT:
		MOV A, VTIME_L
		ADD A, #1
		MOV VTIME_L, A
		LCALL RECARGA_2
		CLR TF2H
		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI
		
	T_DUMMY1:
		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI	
		
	T_DUMMY2:
		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI	
		
RECARGA:
	JC RECARREGA
	RET
		
	RECARREGA:
		MOV VTIME_L, B
		RET
		
RECARGA_2:
	JC RECARREGA_2
	RET
		
	RECARREGA_2:
		CPL P2.7
		MOV VTIME_L, B
		RET


CSEG AT 1000H
	TIMER_TABLE:		 
		TIMER_IDLE:   DB 0F6H, 09CH ; 10s
		TIMER_DUMMY1: DB 0FFH, 0FFH
		TIMER_DUMMY2: DB 0FFH, 0FFH
		TIMER_ALERT:  DB   0H, 0E7H  ; piscar T = 500 ms
	
	
S_IDLE 		  EQU 0
S_TANK_LEVEL  EQU 1
S_FILL 		  EQU 2
S_ALERT		  EQU 3
	
	
INDEX   DATA 30H
STATE   DATA 31H
N_STATE DATA 32H
VTIME_L DATA 33H
VTIME_H DATA 34H
LEVEL   DATA 35H

TIMEOUT       BIT 0
USE_TIMER     BIT 1
TIMEOUT_ALERT BIT 2
	
	
P_DISP EQU P2
	
CSEG AT 100H

MAIN:
	LCALL CONFIGS
	LCALL OSCILATOR_INIT
	LCALL TIMER0_INIT
	;MOV SP, #50
	MOV INDEX, #0
	SETB P0.6
	SETB P0.7
	CLR TIMEOUT
	CLR USE_TIMER
	CLR TIMEOUT_ALERT
	MOV STATE, #S_IDLE
	MOV N_STATE, #S_IDLE
	MOV IT01CF, #007H		//Enable P0.7 to Interrupt
	SETB IT0				//Enable
	CLR EX0
	SETB TR0

LOOP:
	ACALL ENCODE_FSM
	ACALL ENCODE_TIMER
	ACALL K_LOOP
	JMP LOOP
	
	ENCODE_FSM:
		MOV DPTR, #TABLE
		MOV STATE, N_STATE
		MOV A, STATE
		RL A
		JMP @A + DPTR
		
	ENCODE_TIMER:
		MOV DPTR, #TIMER_TABLE
		MOV A, STATE
		RL A
		MOV R0, A
		MOVC A, @A + DPTR
		MOV VTIME_H, A
		MOV A, R0
		INC A
		MOVC A, @A + DPTR
		MOV VTIME_L, A
		MOV B, VTIME_L
		RET

		
	STATE_IDLE:
		MOV P_DISP, #0F9H
		MOV N_STATE, #S_TANK_LEVEL
		SETB USE_TIMER
		RET
		
		
	STATE_TANK_LEVEL:
		MOV P_DISP, #0A4H
		CLR USE_TIMER
		MOV A, P4
		CLR C
		SUBB A, #40
		JZ LEVEL_NORMAL
		JC MENOR_40
		CLR C
		MOV A, P4
		SUBB A, #50
		JZ LEVEL_NORMAL
		JNC MAIOR_50
		MOV N_STATE, #S_IDLE
		RET
			
		LEVEL_NORMAL:
			MOV N_STATE, #S_IDLE
			RET
				
		MENOR_40:
			MOV N_STATE, #S_FILL
			RET
				
		MAIOR_50:
			MOV N_STATE, #S_ALERT
			RET
				
				
	STATE_FILL:
		MOV P_DISP, #0B0H
		CLR USE_TIMER
		MOV N_STATE, #S_IDLE
		JNB P0.1, $					; enquato sensor desativo -> encher
		SETB P0.1
		RET
				
	STATE_ALERT:
		MOV P_DISP, #099H
		MOV N_STATE, #S_IDLE
		SETB USE_TIMER
		SETB EX0
		RET
			
		
		K_LOOP:
			JB USE_TIMER, K_LOOP_TIMER
			RET
			
			K_LOOP_TIMER:
				SETB ET0
				SETB EA
				
				KK_LOOP_TIMER:
					JBC TIMEOUT, TIMEOUT_LABEL
					JBC TIMEOUT_ALERT, TIMEOUT_LABEL
					JMP KK_LOOP_TIMER

				TIMEOUT_LABEL:
					CLR EA
					CLR ET0
					CLR EX0
					RET

TABLE:
	AJMP STATE_IDLE
	AJMP STATE_TANK_LEVEL
	AJMP STATE_FILL
	AJMP STATE_ALERT
	
T_TABLE:
	AJMP T_IDLE
	AJMP T_DUMMY1
	AJMP T_DUMMY2
	AJMP T_ALERT
		
TIMER0_INIT:
	MOV TMOD, #01H					; Modo 16 bit Timer 0
	MOV TH0, #HIGH(-40000)			; 10ms
	MOV TL0, #LOW(-40000)			
    RET


OSCILATOR_INIT:
    MOV FLSCL, #090h		; SYSCLK 48MHz
    MOV CLKSEL, #003h
    RET
		
CONFIGS:
	MOV PCA0MD, #0H			; Desabilitar o WatchDod Timer
	MOV XBR1, #40H			; Ativar a Crossbar 
	RET
						

					
END

