#include <REG51F380.H>

EXTRN CODE (INIT_XRAM, UPDATE_DISP, UPDATE_ARRAY, CYPHER, INCREMENT_ROUTINE, RELOAD_ROUTINE)
PUBLIC	DIGIT_ARRAY, CYPHER_KEY, K_INDEX, INDEX, SEC_KEY, DR_LEN, USER_KEY, P_DISP, RELOAD


K_LOAD 		EQU P0.7
K_SET 		EQU P0.6
UNLOCK_PIN	EQU	P0.5

B_TENSION 	EQU P1.0
BUZZER		EQU P1.1	
	
P_DISP		EQU P2

; VARIÁVEIS
STATE		DATA 30H
N_STATE		DATA 31H
FAILED_T 	DATA 32H
INDEX		DATA 33H
K_INDEX		DATA 34H	
	

;BITS
T_OV 		BIT 0H //TIME OUT
BLOCKED		BIT 1H


; MÁSCARAS
K_LEN		EQU 3
S_LEN		EQU 7
DR_LEN		EQU 15

; ESTADOS
S_READY		EQU 0
S_LOCKED	EQU 1
S_DECRYPT	EQU 2 
S_OPEN		EQU 3
S_ENCRYPT	EQU 4
S_FAIL		EQU 5
S_BLOCKED	EQU 6	
S_DUMMY		EQU 7
	

;-------- MEMORY POSITIONS --------
;CHECKSUM
;CHECK_BEG	EQU 45H
;CHECK_END	EQU	48H
	
;ARRAYS
SEC_KEY		EQU 40H
USER_KEY	EQU 45H
	
DIGIT_ARRAY	EQU 1200H
CYPHER_KEY	EQU	1300H	
	
RELOAD 		EQU	1400H

CSEG AT 0H
	AJMP INIT
CSEG AT 0x000B
	JMP ISM_LOOP 	
CSEG AT 50H
	
	INIT:
		MOV  PCA0MD, #0
		MOV XBR1, #40H
		
		;INIT SP
		MOV SP, #50H   ; altera logo o stackPointer para o banco da posição 50H
		
	   ;CYSCLK INIT
		MOV  FLSCL, #090h
		MOV  CLKSEL, #003h
		
		;TIMER INIT
		MOV  TMOD, #002h
		MOV  CKCON, #002h
		MOV  TL0, #(-250)
		MOV  TH0, #(-250)
		
		
		;TIMER INTERRUPTOR ENABLE
		MOV  IE, #082h
		
		;INIT BITS
		SETB K_LOAD
		SETB k_SET
		
		CLR T_OV
		
		; INIT VALUES
		MOV INDEX, #0
		MOV K_INDEX, #0
		MOV FAILED_T, #0
		MOV STATE, #S_READY
		
		
		;INIT VC VALUES
		MOV R0, #0
		MOV R7, #18
		MOV DPTR, #RELOAD
		
		LCALL INIT_XRAM
		
		MOV B, #0
		
		JNB BLOCKED, FSM_LOOP
		MOV STATE, #S_BLOCKED

	FSM_LOOP:
		ACALL ENCODE_FSM
		SJMP FSM_LOOP
	
	K_LOOP:
		JB T_OV, K_SET_PRESSED
		JNB K_SET, K_SET_PRESSED
		JB K_LOAD, k_LOOP
	
	K_LOAD_PRESSED:
		JNB K_LOAD, $

		INC K_INDEX
		MOV INDEX, #0
		
		MOV STATE, N_STATE
		RET
		
	K_SET_PRESSED:
		JNB K_SET, $
		INC INDEX
		RET
		
	
	ENCODE_FSM:
		MOV DPTR, #TABLE
		MOV A, STATE
		ANL A, #S_LEN
		MOV STATE, A
		RL A
		JMP @A+DPTR
		
	TABLE:
		AJMP STATE_READY
		AJMP STATE_LOCKED
		AJMP STATE_DECRYPT
		AJMP STATE_OPEN
		AJMP STATE_ENCRYPT
		AJMP STATE_FAIL
		AJMP STATE_BLOCKED
		AJMP STATE_DUMMY
	
	STATE_READY:
		;TENSÃO DE BLOQUEIO
		SETB P1.0
		
		MOV 40H, #0AFH ;0
		MOV 41H, #0B3H ;1
		MOV 42H, #30H ;2
		MOV 43H, #27H ;3
		
		
		
		MOV P_DISP, #0C7H ;L
		
		MOV N_STATE, #S_LOCKED
		
		ACALL K_LOOP
		
		MOV K_INDEX, #0
		
		RET
	STATE_LOCKED:
		;PARAR O TIMER
		CLR TR0
		;LIMPAR O PONTO DECIMAL PARA CASO SE CARREGUE NO K_LOAD E ELE FIQUE ACESO
		CLR P2.7
		
		LCALL UPDATE_DISP
		LCALL UPDATE_ARRAY
		ACALL K_LOOP
		
		MOV A, INDEX
		ANL A, #DR_LEN
		MOV INDEX, A
		
		CLR C
		MOV A, #K_LEN
		SUBB A, K_INDEX
		
		MOV A, STATE
		ADDC A, #0
		MOV STATE, A
		
		RET

	STATE_DECRYPT:
		MOV K_INDEX, INDEX
		
		MOV A, #SEC_KEY
		ADD A, INDEX
		MOV R0, A
		MOV A, @R0
		MOV R0, A
		
		LCALL CYPHER

		;COMPARE
		MOV A, #USER_KEY
		ADD A, INDEX
		MOV R1, A
		MOV A, @R1
		
		XRL A, R0
		
		INC INDEX
		
		
		ADD A, B	;SE O A FOR ALGUMA VEZ DIFERENTE DE 0, O B 
		MOV B, A	;VAI GUARDAR UM VALOR DIFERENTE DE 0 E ASSIM SABEMOS SE 
					; ALGUM NUMERO ERA INCORRETO
			
		CLR C
		MOV A, #K_LEN
		SUBB A, INDEX
		
		JNC END_DECRYPT
		MOV INDEX, #0
		MOV STATE, #S_OPEN
		MOV A, B
		MOV B, #0
		JZ END_DECRYPT
		MOV STATE, #S_FAIL		
		
		END_DECRYPT:
		RET
		
	STATE_OPEN:
		;ENABLE TIMER
		SETB TR0
		
		
		MOV FAILED_T, #0
		
		MOV P_DISP, #0A3H ;LETRA O
		
		;DESLIGAR TENSÃO DE BLOQUEIO
		CLR B_TENSION
		
		MOV STATE, #S_ENCRYPT
		MOV N_STATE, #S_LOCKED
		
		ACALL K_LOOP
		
		;TIMER OFF
		CLR TR0
		
		CLR T_OV
		
		MOV INDEX, #0
		MOV K_INDEX, #0
		
		;DESLIGAR O PONTO DECIMAL PARA O CASO DESTE FICAR ACESO
		SETB P2.7
		;TENSÃO DE BLOQUEIO
		SETB B_TENSION
		
		
		RET
		
	STATE_ENCRYPT:
		;DEFENIR NOVA PASS
		MOV N_STATE, #S_ENCRYPT
		
				
		LCALL UPDATE_DISP
		
		MOV R0, INDEX
		
		;ENCRIPTAR
		LCALL CYPHER
		
		;GUARDAR O VALOR
		MOV A, #SEC_KEY
		ADD A, K_INDEX
		MOV R1, A  
		MOV A, R0
		MOV @R1, A
		
		ACALL K_LOOP
		
		MOV A, INDEX
		ANL A, #DR_LEN
		MOV INDEX, A
		
		CLR C
		MOV A, #K_LEN
		SUBB A, K_INDEX
		
		JNC END_ENCRYPT 
		
		MOV STATE, #S_LOCKED
		MOV N_STATE, #S_LOCKED
		
		MOV P_DISP, #0C7H ;L
		JB K_LOAD, $
		JNB K_LOAD, $
		
		MOV K_INDEX, #0
		MOV INDEX, #0
		
		
		END_ENCRYPT:
		
		RET		

	STATE_FAIL:
		;ENABLE TIMER
		MOV  TCON, #010h
		

		MOV P_DISP, #8EH ;F
		
		MOV STATE, #S_LOCKED 
		
		
		JNB T_OV, $
		CLR T_OV

		MOV INDEX, #0 
		MOV K_INDEX,#0

		INC FAILED_T

		CLR C
		MOV A, #2
		SUBB A, FAILED_T
		
		;CASO FAILED_T = 3 PASSA PARA S_BLOCKED	

		JNC NOT_BLOCKED
		MOV STATE, #S_BLOCKED
		SETB BLOCKED
		NOT_BLOCKED:
		
		RET
		
	STATE_BLOCKED:
		;RESET FAILED_T VARIABLE
		MOV FAILED_T, #0
		MOV STATE, #S_READY	
		
		MOV P_DISP, #83H ;b
		
		;RECOVER CONDITION
		JB K_SET, $
		JNB K_SET, $
		
		JB UNLOCK_PIN, $
		JNB UNLOCK_PIN, $

		JB K_SET, $
		JNB K_SET, $	
	
		JB K_SET, $
		JNB K_SET, $	

		;PARAR O TIMER
		CLR TR0
		CLR BLOCKED
		MOV FAILED_T, #0
			
		RET
		
	STATE_DUMMY:
		MOV STATE, #S_READY
		RET
			
;		---------------------------------
;		|			TIMERS				|		
;		|			INTERRUPT			|
;		---------------------------------
		
		
	ISM_LOOP:
		PUSH PSW
		PUSH ACC
		PUSH DPL
		PUSH DPH
		
		SETB RS0 ;MUDA PARA O BANCO 1 DE REGISTOS
	
		MOV DPTR, #T_TABLE
		MOV A, STATE
		CLR C
		SUBB A, #3
		ANL A, #3
		RL A
		JMP @A+DPTR
		

	T_TABLE:
		AJMP TIMER_DUMMY
		AJMP TIMER_OPEN
		AJMP TIMER_FAIL
		AJMP TIMER_BLOCKED
	
	TIMER_OPEN:
		MOV DPTR, #RELOAD
		MOV R0, #3
		
		;OS VALORES REFERENTES AOS 30seg COMEÇAM NO 3
		;OS VALORES REFERENTES AOS 500ms COMEÇAM NO 0
		
		CLR C
		CLR EA
		LCALL INCREMENT_ROUTINE
		MOV T_OV, C
		
		MOV R0, #3
		LCALL RELOAD_ROUTINE
		SETB EA
		
		MOV R0, #0
		
		; BLINK PONTO DECIMAL

		LCALL INCREMENT_ROUTINE
		
		JNC NOT_500MS_YET
		CPL P2.7		
		
		NOT_500MS_YET:
		MOV R0, #0		
		LCALL RELOAD_ROUTINE


		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI
	
		
	TIMER_FAIL:
		; O PROGRAMA VAI ENTRAR NO FAIL PELA PRIMEIRA VEZ COM FAILED_T=0
		; E SO DEPOIS DE PASSAREM O TEMPO É QUE INCREMENTA 
		MOV DPTR, #RELOAD
		MOV R0, #6
		
		MOV A, FAILED_T
		RL A
		RL A
		ADD A, R0
		MOV R0, A
		MOV R7, A ;ASSIM GUARDA A POSIÇÃO DO 1 BYTE
		
		CLR C
		CLR EA
		LCALL INCREMENT_ROUTINE
		MOV T_OV, C
		MOV A, R7
		MOV R0, A
		LCALL RELOAD_ROUTINE
		SETB EA
		
		POP DPH
		POP DPL		
		POP ACC
		POP PSW
		RETI
		
	TIMER_BLOCKED:

		CPL BUZZER ; 4KHz

		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI
		
	TIMER_DUMMY:
		
		POP DPH
		POP DPL
		POP ACC
		POP PSW
		RETI	
	
					
		CSEG AT DIGIT_ARRAY
				DB 0C0H, 0F9H, 0A4H, 0B0H, 099H, 092H, 082H, 0F8H, 080H, 090H, 088H, 083H, 0C6H, 0A1H, 086H, 08EH
		
		CSEG AT CYPHER_KEY
				DB 0AFH,0B2H,032H,024H
					
		CSEG AT RELOAD 
				DB 038H, 0F6H, 0FFH, 038H, 0F6H, 0C4H, 038H, 0F6H, 0C4H, 0FFH, 038H, 0ECH, 0C4H, 0FFH, 038H, 0E2H, 0C4H, 0FFH
				;   0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17
				;  B1ms  B2ms  B3ms  B1_O  B2_O  B3_O  B1_F  B2_F  B3_F  B4_F  B1_60 B2_60 B3_60  B4_60 B1_90 B2_90 B3_90 B4_90	
				;  200    10    0    200    10    60   200    10    60    0    200    20     60     0    200   30    60    0    
				
				
	END